<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<ruleset xmlns="http://pmd.sf.net/ruleset/1.0.0" name="pmd-eclipse" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://pmd.sf.net/ruleset_xml_schema.xsd" xsi:schemaLocation="http://pmd.sf.net/ruleset/1.0.0 http://pmd.sf.net/ruleset_xml_schema.xsd">
   <description>PMD Plugin preferences rule set</description>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty finalize methods" name="EmptyFinalizer" typeResolution="true">
      <description>
       If the finalize() method is empty, then it does not need to exist.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

   //MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
      /Block[count(*)=0]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

   public class Foo {
       protected void finalize() {}
   }

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeOnlyCallsSuperFinalize" message="Finalize should do something besides just calling super.finalize()" name="FinalizeOnlyCallsSuperFinalize" typeResolution="true">
      <description>
If the finalize() is implemented, it should do something besides just calling
super.finalize().
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration[MethodDeclarator[@Image="finalize"][not(FormalParameters/*)]]
   /Block[count(BlockStatement)=1]
     /BlockStatement[
       Statement/StatementExpression/PrimaryExpression
      /PrimaryPrefix[@Image="finalize"]
      ]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
           
public class Foo {
   protected void finalize() {
     super.finalize();
   }
}
           
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Finalize methods should not be overloaded" name="FinalizeOverloaded" typeResolution="true">
      <description>
   Methods named finalize() should not have parameters.  It is
   confusing and probably a bug to overload finalize().  It will
   not be called by the VM.
   </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration
 /MethodDeclarator[@Image='finalize'][FormalParameters[count(*)>0]]

            ]]></value>
         </property>
      </properties>
      <example><![CDATA[

   public class Foo {
       // this is confusing and probably a bug
       protected void finalize(int a) {
       }
   }

   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Last statement in finalize method should be a call to super.finalize()" name="FinalizeDoesNotCallSuperFinalize" typeResolution="true">
      <description>
       If the finalize() is implemented, its last action should be to call super.finalize
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[


//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
   /Block
      /BlockStatement[last()]
      [not(Statement/StatementExpression/PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
      [not(Statement/TryStatement/FinallyStatement
       /Block/BlockStatement/Statement/StatementExpression
        /PrimaryExpression/PrimaryPrefix[@Image='finalize'])]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
   protected void finalize() {
       something();
       // neglected to call super.finalize()
   }
}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Explicit call of finalize method" name="ExplicitCallToFinalize" typeResolution="true">
      <description>
       An explicit call was made to a finalize method.  Finalize methods
       are meant to be executed at most once (by the garbage collector).
       Calling it explicitly could result in the method being executed
       twice for that object (once by you, once by the garbage collector).
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryExpression[PrimarySuffix
 /Arguments[count(*) = 0]]
  /PrimaryPrefix
   /Name[@Image = 'finalize' or ends-with(@Image, '.finalize')]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 public void close()  {
    finalize();       // this is bad
    foo.finalize();   // this is also bad
    this.finalize();  // this is bad but currently not flagged
    super.finalize(); // this is OK
    foo.finalize(3);  // this is arguably OK because the method is overloaded
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="If you override finalize(), make it protected" name="FinalizeShouldBeProtected" typeResolution="true">
      <description>
      If you override finalize(), make it protected.  Otherwise, subclasses
          may not called your implementation of finalize.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void finalize() {
  // do something
 }
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule" dfa="false" externalInfoUrl="" message="The private field ''{0}'' is declared, but is not used by the class." name="UnusedPrivateField" typeResolution="true">
      <description>
Detects when a private field is declared and/or assigned a value, but not used.
    </description>
      <priority>3</priority>
      <example><![CDATA[

public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedLocalVariableRule" dfa="false" externalInfoUrl="" message="The local variable ''{0}'' is declared, but is not used (except possibly for initial assignment)." name="UnusedLocalVariable" typeResolution="true">
      <description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
      <priority>3</priority>
      <example><![CDATA[

public void doSomething() {
  int i = 5; // Unused
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule" dfa="false" externalInfoUrl="" message="The private method ''{0}'' is declared, but is not used by the class." name="UnusedPrivateMethod" typeResolution="true">
      <description>
Unused Private Method detects when a private method is declared but is unused.
    </description>
      <priority>3</priority>
      <example><![CDATA[

public class Something {
 private void foo() {} // unused
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnusedFormalParameterRule" dfa="false" externalInfoUrl="" message="The formal parameter ''{0}'' is declared, but is not used by the method." name="UnusedFormalParameter" typeResolution="true">
      <description>
Avoid passing parameters to methods and then not using those parameters.
    </description>
      <priority>3</priority>
      <example><![CDATA[

public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.SuspiciousOctalEscape" dfa="false" externalInfoUrl="" message="Suspicious decimal characters following octal escape in string literal" name="SuspiciousOctalEscape" typeResolution="true">
      <description>
      A suspicious octal escape sequence was found inside a String literal.
      The Java language specification (section 3.10.6) says an octal
      escape sequence inside a literal String shall consist of a backslash
      followed by:

           OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

      Any octal escape sequence followed by non-octal digits can be confusing,
      e.g. "\038" is interpreted as the octal escape sequence "\03" followed by
      the literal character "8".
      </description>
      <priority>3</priority>
      <example><![CDATA[

 public class Foo {
    public void foo() {
       // interpreted as octal 12, followed by character '8'
       System.out.println("suspicious: \128");
    }
 }

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This return statement may have some unnecessary parentheses" name="UnnecessaryParentheses" typeResolution="true">
      <description>
      Sometimes return statement expressions are wrapped in unnecessary parentheses,
 making them look like a function call.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//ReturnStatement
          /Expression
           /PrimaryExpression
            /PrimaryPrefix
             /Expression[count(*)=1]
              /PrimaryExpression
              /PrimaryPrefix
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Foo {
      boolean bar() {
          return (true);
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An empty 'if' statement checks a condition but does nothing about it.  Usually, code still needs to be added to the statement, or the entire statement should be removed." name="EmptyIfStmt" typeResolution="true">
      <description>
  Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  //IfStatement/Statement/Block[count(*) = 0]
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    if (foo == 0) {
       // why bother checking up on foo?
    }
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An empty 'while' statement does nothing.  If it is a timing loop, then you should use 'Thread.sleep()' for it; if it is a 'while' loop that does a lot in its conditional expression, rewrite it to make it clearer." name="EmptyWhileStmt" typeResolution="true">
      <description>
  Empty While Statement finds all instances where a while statement
  does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
  it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
                  //WhileStatement/Statement[./Block[count(*) = 0]  or ./EmptyStatement]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  while (a == b) {
    // not good
  }
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty 'try' blocks." name="EmptyTryBlock" typeResolution="true">
      <description>
  Avoid empty try blocks - what's the point?
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  //TryStatement/Block[1][count(*) = 0]
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  // this is bad
  public void bar() {
      try {
      } catch (Exception e) {
          e.printStackTrace();
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty 'finally' blocks.  They can be deleted." name="EmptyFinallyBlock" typeResolution="true">
      <description>
  Avoid empty finally blocks - these can be deleted.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//FinallyStatement[count(Block/BlockStatement) = 0]
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  // this is bad
  public void bar() {
      try {
          int x=2;
      } finally {
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty 'switch' statements." name="EmptySwitchStatements" typeResolution="true">
      <description>
      Avoid empty switch statements.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  //SwitchStatement[count(*) = 1]
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Foo {
   public void bar() {
    int x = 2;
    switch (x) {
     // once there was code here
     // but it's been commented out or something
    }
   }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid using an outer loop's index variable in an inner loop's update expression.  It is usually a mistake, and it is confusing even if it is what was intended." name="JumbledIncrementer" typeResolution="true">
      <description>
     Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.
     </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 //ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]
             ]]></value>
         </property>
      </properties>
      <example><![CDATA[
 public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This 'for' loop could be simplified to a 'while' loop to increase conciseness and readability." name="ForLoopShouldBeWhileLoop" typeResolution="true">
      <description>
      Some for loops can be simplified to while loops - this makes them more concise.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
 //ForStatement
  [count(*) > 1]
  [not(ForInit)]
  [not(ForUpdate)]
  [not(Type and Expression and Statement)]
 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Foo {
      void bar() {
          for (;true;) true; // No Init or Update part, may as well be: while (true)
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporary" dfa="false" externalInfoUrl="" message="Avoid unnecessary temporaries when converting primitives to 'String's.  The static 'toString()' method on the wrapper class allows the 'new' to be removed." name="UnnecessaryConversionTemporary" typeResolution="true">
      <description>
      Avoid unnecessary temporaries when converting primitives to Strings
      </description>
      <priority>3</priority>
      <example><![CDATA[
  public String convert(int x) {
      // this wastes an object
      String foo = new Integer(x).toString();
      // this is better
      return Integer.toString(x);
    }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.DoubleCheckedLocking" dfa="false" externalInfoUrl="" message="Double checked locking is not thread safe in Java." name="DoubleCheckedLocking" typeResolution="true">
      <description>
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid returning from a finally block" name="ReturnFromFinallyBlock" typeResolution="true">
      <description>
  Avoid returning from a finally block - this can discard exceptions.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

 //FinallyStatement//ReturnStatement
 
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Bar {
 public String bugga() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid empty synchronized blocks" name="EmptySynchronizedBlock" typeResolution="true">
      <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  //SynchronizedStatement/Block[1][count(*) = 0]
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  // this is bad
  public void bar() {
      synchronized (this) {}
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryReturn" message="Avoid unnecessary return statements" name="UnnecessaryReturn" typeResolution="true">
      <description>
Avoid unnecessary return statements
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
//ReturnStatement
 [parent::Statement
  [parent::BlockStatement
   [parent::Block
    [parent::MethodDeclaration/ResultType[@Void='true']
    ]
   ]
  ]
 ]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public void bar() {
  int x = 42;
  return;
 }
}
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Empty static initializer was found" name="EmptyStaticInitializer" typeResolution="true">
      <description>
       An empty static initializer was found.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
//ClassOrInterfaceBodyDeclaration/Initializer[@Static='true']/Block[count(*)=0]
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   public class Foo {
  // why are there no statements in this static block?
  static {}
 }
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Do not use 'if' statements that are always true or always false" name="UnconditionalIfStatement" typeResolution="true">
      <description>
      Do not use "if" statements that are always true or always false.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 //IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid instantiating Boolean objects; you can usually invoke Boolean.TRUE instead." name="BooleanInstantiation" typeResolution="true">
      <description>
   Avoid instantiating Boolean objects, instead use Boolean.TRUE or Boolean.FALSE.
   </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//PrimaryExpression
[
PrimaryPrefix/AllocationExpression[not (ArrayDimsAndInits) and (ClassOrInterfaceType/@Image='Boolean' or ClassOrInterfaceType/@Image='java.lang.Boolean')]
or
(
PrimaryPrefix/Name[@Image='Boolean.valueOf']
and
PrimarySuffix/Arguments//BooleanLiteral
)
]

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 private Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE;
}
   
   ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="These nested if statements could be combined" name="CollapsibleIfStatements" typeResolution="true">
      <description>
      Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//IfStatement[@Else='false']/Statement
 /IfStatement[@Else='false']
 |
//IfStatement[@Else='false']/Statement
 /Block[count(BlockStatement)=1]/BlockStatement
  /Statement/IfStatement[@Else='false']
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  public class Foo {
      void bar() {
          if (x) {
           if (y) {
             // do stuff
           }
          }
      }
  }
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.SimplifyBooleanReturns" dfa="false" externalInfoUrl="" message="Avoid unnecessary if..then..else statements when returning a boolean" name="SimplifyBooleanReturns" typeResolution="true">
      <description>
Avoid unnecessary if..then..else statements when returning a boolean
    </description>
      <priority>3</priority>
      <example><![CDATA[

public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid unnecessary comparisons in boolean expressions" name="SimplifyBooleanExpressions" typeResolution="true">
      <description>
  Avoid unnecessary comparisons in boolean expressions - this makes simple code seem complicated.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//EqualityExpression/PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral

              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="A 'switch' statement should have a default case." name="SwitchStmtsShouldHaveDefault" typeResolution="true">
      <description>
    Switch statements should have a default label.
    </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
    //SwitchStatement[not(SwitchLabel[count(*) = 0])]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidReassigningParameters" dfa="false" externalInfoUrl="" message="Avoid reassigning parameters such as ''{0}''  Reassigning values to parameters is a questionable practice, and can mislead someone reading the code.  Use a temporary local variable instead." name="AvoidReassigningParameters" typeResolution="true">
      <description>
Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.
    </description>
      <priority>2</priority>
      <example><![CDATA[

public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.SwitchDensityRule" dfa="false" externalInfoUrl="" message="A high ratio of statements to labels in a 'switch' statement implies that the 'switch' statement is doing too much work.  Consider moving the statements either into new methods, or creating subclasses based on the 'switch' variable." name="SwitchDensity" typeResolution="true">
      <description>
 A high ratio of statements to labels in a switch statement implies that the switch
 statement is doing too much work.  Consider moving the statements either into new
 methods, or creating subclasses based on the switch variable.
      </description>
      <priority>3</priority>
      <properties>
         <property name="minimum" value="10"/>
      </properties>
      <example><![CDATA[
 
   public class Foo {
     private int x;
     public void bar() {
       switch (x) {
         case 1: {
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           break;
         }

         case 2: {
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           break;
         }
       }
     }
   }
 
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod" dfa="false" externalInfoUrl="" message="Calling overridable methods during construction poses a risk of invoking methods on an incompletely constructed object.  This situation can be difficult to discern.  It may leave the subclass unable to construct its superclass or forced to replicate the construction process completely within itself, losing the ability to call 'super()'.  If the default constructor contains a call to an overridable method, the subclass may be completely uninstantiable." name="ConstructorCallsOverridableMethod" typeResolution="true">
      <description>
      Calling overridable methods during construction poses a risk of invoking methods on an
          incompletely constructed object.  This situation can be difficult to discern.
      It may leave the sub-class unable to construct its superclass or forced to
          replicate the construction process completely within itself, losing the ability to call
      super().  If the default constructor contains a call to an overridable method,
          the subclass may be completely uninstantiable.   Note that this includes method calls
          throughout the control flow graph - i.e., if a constructor Foo() calls a private method
            bar() that calls a public method buz(), there's a problem.
      </description>
      <priority>1</priority>
      <example><![CDATA[
  
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name.toUpperCase();
      }
    }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AccessorClassGeneration" dfa="false" externalInfoUrl="" message="Avoid instantiation through private constructors from outside of the constructor's class." name="AccessorClassGeneration" typeResolution="true">
      <description>
      Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
      A factory method, or non-privitization of the constructor can eliminate this situation.
      The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
      scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
      one with package scope, though not visible to the naked eye.
      </description>
      <priority>3</priority>
      <example><![CDATA[
  
  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//Causes generation of accessor
    }
    public class InnerClass {
      private InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//OK, due to public constructor
    }
    public class InnerClass {
      public InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = InnerClass.getInnerClass();//OK
    }
    public static class InnerClass {
      private InnerClass(){
      }
      private static InnerClass getInnerClass(){
        return new InnerClass();
      }
    }
  }

  public class OuterClass {
    private OuterClass(){
    }
    public class InnerClass {
      void method(){
        OuterClass oc = new OuterClass();//Causes generation of accessor
      }
    }
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This final field could be made static" name="FinalFieldCouldBeStatic" typeResolution="true">
      <description>
      If a final field is assigned to a compile-time constant, it could be
          made static, thus saving overhead in each object
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Non-static initializers are confusing" name="NonStaticInitializer" typeResolution="true">
      <description>
       A nonstatic initializer block will be called any time a constructor
       is invoked (just prior to invoking the constructor).  While this
       is a valid language construct, it is rarely used and is confusing.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//ClassOrInterfaceBodyDeclaration/Initializer[@Static='false']

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#DefaultLabelNotLastInSwitchStmt" message="The default label should be the last label in a switch statement" name="DefaultLabelNotLastInSwitchStmt" typeResolution="true">
      <description>
By convention, the default label should be the last label in a switch statement.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//SwitchStatement
 [not(SwitchLabel[position() = last()][@Default='true'])]
 [SwitchLabel[@Default='true']]

                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:  // do something
      break;
   default:  // the default case should be last, by convention
      break;
   case 2:
      break;
  }
 }
}   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="A non-case label was present in a switch statement" name="NonCaseLabelInSwitchStatement" typeResolution="true">
      <description>
       A non-case label (e.g. a named break/continue label) was present in a switch statement.
       This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
 
    //SwitchStatement//BlockStatement/Statement/LabeledStatement
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
public class Foo {
 void bar(int a) {
  switch (a)
  {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid equality comparisons with Double.NaN; these are likely to be logic errors." name="BadComparison" typeResolution="true">
      <description>
  Avoid equality comparisons with Double.NaN - these are
likely to be logic errors.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
public class Bar {
int x = (y == Double.NaN);
}
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Don't use equals() to compare against null" name="EqualsNull" typeResolution="true">
      <description>
         Newbie programmers sometimes get the comparison concepts confused
         and use equals() to compare to null.
        </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
    //PrimaryExpression
     [PrimaryPrefix/Name[ends-with(@Image, 'equals')]]
     [PrimarySuffix/Arguments/ArgumentList
      /Expression/PrimaryExpression/PrimaryPrefix
       /Literal/NullLiteral]
    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
       
    class Bar {
       void foo() {
           String x = "foo";
           if (x.equals(null)) { // bad!
            doSomething();
           }
       }
    }
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.design.ConfusingTernary" dfa="false" externalInfoUrl="" message="Avoid if (x != y) ..; else ..;" name="ConfusingTernary" typeResolution="true">
      <description>
          In an "if" expression with an "else" clause, avoid negation in
          the test.  For example, rephrase:
            if (x != y) diff(); else same();
          as:
            if (x == y) same(); else diff();
          Most "if (x != y)" cases without an "else" are often return
          cases, so consistent use of this rule makes the code easier
          to read.  Also, this resolves trivial ordering problems, such
          as "does the error case go first?" or "does the common case
          go first?".
        </description>
      <priority>3</priority>
      <example><![CDATA[
          
          return (x != y) ? diff : same;
          
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead" name="InstantiationToGetClass" typeResolution="true">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead
      </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
class Foo {
 Class c = new String().getClass();
}
    
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.IdempotentOperations" dfa="false" externalInfoUrl="" message="Avoid idempotent operations (like assigning a variable to itself)" name="IdempotentOperations" typeResolution="true">
      <description>
      Avoid idempotent operations - they are silly.
      </description>
      <priority>3</priority>
      <example><![CDATA[
      
    public class Foo {
     public void bar() {
      int x = 2;
      x = x;
     }
    }
      
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid protected fields in a final class.  Change to private or package access." name="AvoidProtectedFieldInFinalClass" typeResolution="true">
      <description>
     Do not use protected fields in final classes since they cannot be subclassed.
    Clarify your intent by using private or package access modifiers instead.
         </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//ClassOrInterfaceDeclaration[@Final='true']//FieldDeclaration[@Protected='true'] 
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
     public final class Bar {
      private int x;
      protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
      Bar() {}
   }
         ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid calling finalize() explicitly" name="AvoidCallingFinalize" typeResolution="true">
      <description>
  finalize() is called by the garbage collector on an object when garbage collection determines
  that there are no more references to the object.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='finalize'
	or ends-with(@Image,'.finalize')
	]
or @Image='finalize'
]

    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[


	void foo() {
	    Bar b = new Bar();
	    b.finalize();
	}


      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type." name="AvoidInstanceofChecksInCatchClause" typeResolution="true">
      <description>
  Each caught exception type should be handled in its own catch clause.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
    
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

    // Avoid this
      try {
            ...something...
      }
      catch (Exception ee) {
            if (ee instanceof IOException) {
                cleanup();
            }
      }

      // Prefer this:
      try {
          ...something...
      }
      catch (IOException ee) {
            cleanup();
      }

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This abstract class does not have any abstract methods" name="AbstractClassWithoutAbstractMethod" typeResolution="true">
      <description>
      The abstract class does not contain any abstract methods. An abstract class suggests
      an incomplete implementation, which is to be completed by subclasses implementing the
      abstract methods. If the class is intended to be used as a base class only (not to be instantiated
      direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
              
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public abstract class Foo {
	void int method1() { ... }
	void int method2() { ... }
	// consider using abstract methods or removing
	// the abstract modifier and adding protected constructors
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyConditional" message="No need to check for null before an instanceof" name="SimplifyConditional" typeResolution="true">
      <description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
           </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                      
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      //PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression//PrimaryPrefix/Name/@Image]]]
 
                  ]]></value>
         </property>
      </properties>
      <example><![CDATA[
      
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      
           ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable" dfa="false" externalInfoUrl="" message="A catch statement should never catch throwable since it includes errors" name="AvoidCatchingThrowable" typeResolution="true">
      <description>
This is dangerous because if a java.lang.Error, for example OutOfMemmoryError,
occurs then it will be caught. The container should handle java.lang.Error.
If application code will catch them, try to log them (which will probably fail)
and continue silently the situation will not be desirable.
      </description>
      <priority>3</priority>
      <example><![CDATA[
                
SimpleDateFormat sdf = null;
try {
    sdf = new SimpleDateFormat("yyyy-MM-dd");
} catch (Throwable th) {  //Should not catch throwable
    th.printStackTrace();
}
                
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid catching NullPointerException; remove the cause of the NPE instead." name="AvoidCatchingNPE" typeResolution="true">
      <description>
      Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.
    </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
            
//CatchStatement/FormalParameter/Type
 /ReferenceType/ClassOrInterfaceType[@Image='NullPointerException']
 
        ]]></value>
         </property>
      </properties>
      <example><![CDATA[  
try {
  ...
} catch (NullPointerException npe) {
  ...
}

         ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid throwing null pointer exceptions; this is confusing to others, since the assumption is that the VM threw NPE due to faulty code.  If you are reporting an invalid argument, use 'IllegalArgumentException' instead." name="AvoidThrowingNullPointerException" typeResolution="true">
      <description>
Avoid throwing a NullPointerException - it's confusing because most people will assume that the
   VM threw NPE.  Consider using InvalidArgumentException("Null parameter") which will be clearly seen as
  a programmer initiated exception..  Use IllegalArgumentException or IllegalStateException instead.
      </description>
      <priority>1</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
              
  //AllocationExpression/ClassOrInterfaceType[@Image='NullPointerException']
   
          ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        
  throw new NullPointerException();
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid instantiating String objects; this is unnecessary." name="StringInstantiation" typeResolution="true">
      <description>
    Avoid instantiating String objects; this is usually unnecessary.
    </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                   
    //AllocationExpression[ClassOrInterfaceType/@Image='String'][count(.//Expression) < 2][not(ArrayDimsAndInits)]
                    
               ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Foo {
 private String bar = new String("bar"); // just do a String bar = "bar";
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.strings.StringToStringRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#StringToString" message="Avoid calling toString() on String objects; this is unnecessary" name="StringToString" typeResolution="true">
      <description>
    Avoid calling toString() on String objects; this is unnecessary
    </description>
      <priority>3</priority>
      <example><![CDATA[

public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.imports.DuplicateImportsRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#DuplicateImports" message="Avoid duplicate imports such as ''{0}''" name="DuplicateImports" typeResolution="true">
      <description>
    Avoid duplicate import statements.
    </description>
      <priority>4</priority>
      <example><![CDATA[

import java.lang.String;
import java.lang.*;
public class Foo {}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3)." name="DontImportJavaLang" typeResolution="true">
      <description>
    Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    </description>
      <priority>4</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
//ImportDeclaration
 [starts-with(Name/@Image, 'java.lang')]
 [not(starts-with(Name/@Image, 'java.lang.ref'))]
 [not(starts-with(Name/@Image, 'java.lang.reflect'))]
 [not(starts-with(Name/@Image, 'java.lang.annotation'))]
 [not(starts-with(Name/@Image, 'java.lang.instrument'))]
 [not(starts-with(Name/@Image, 'java.lang.management'))]
                
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid variables with short names.  Choose a name that reflects the purpose of the variable." name="ShortVariable" typeResolution="true">
      <description>
Detects when a field, local or parameter has a short name.
    </description>
      <priority>3</priority>
      <properties>
         <property name="xpath" pluginname="true">
            <value><![CDATA[
                  
    //VariableDeclaratorId[string-length(@Image) < 3]
     [not(ancestor::ForInit)]
     [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class Something {
  private int q = 15; // VIOLATION - Field

  public static void main( String as[] ) {  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local

    for (int i = 0; i < 10; i++) { // Not a Violation (inside FOR)
      r += q;
    }
  }
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Avoid using short method names.  Choose a name that reflects what the method does." name="ShortMethodName" typeResolution="true">
      <description>
Detects when very short method names are used.
     </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                  
    //MethodDeclarator[string-length(@Image) < 3]
                  
              ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class ShortMethod {
  public void a( int i ) { // Violation
  }
}

     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Abstract classes should be named 'AbstractXxx'" name="AbstractNaming" typeResolution="true">
      <description>
  Abstract classes should be named 'AbstractXXX'.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
//ClassOrInterfaceDeclaration
 [@Abstract='true' and @Interface='false']
 [starts-with(@Image,'Abstract') = 0]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public abstract class Foo { // should be AbstractFoo
}

       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#SuspiciousHashcodeMethodName" message="The method name and return type are suspiciously close to hashCode()" name="SuspiciousHashcodeMethodName" typeResolution="true">
      <description>
The method name and return type are suspiciously close to hashCode(), which
may mean you are intending to override the hashCode() method.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//MethodDeclaration
 [ResultType
  //PrimitiveType
   [@Image='int']
   [//MethodDeclarator
    [@Image='hashcode' or @Image='HashCode' or @Image='Hashcode']
    [not(FormalParameters/*)]]]

                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
 public int hashcode() {
 // oops, this probably was supposed to be hashCode
 }
}
    
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="The field name indicates a constants but its modifiers don't" name="SuspiciousConstantFieldName" typeResolution="true">
      <description>
       A field name is all in uppercase characters, which in sun's java naming 
       conventions indicate a constant. However, the field is not final.
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
 
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
    
public class Foo {
	// this is bad, since someone could accidentally 
	// do PI = 2.71828; which is actualy e
	// final double PI = 3.16; is ok
	double PI = 3.16;
	
}
    
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="The method name and parameter number are suspiciously close to equals(Object)" name="SuspiciousEqualsMethodName" typeResolution="true">
      <description>
              The method name and parameter number are suspiciously close to
     equals(Object), which may mean you are trying (and failing) to override the equals(Object)
        method.
        </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
        
//MethodDeclarator [
(
@Image = 'equals'
  and count(FormalParameters/*) = 1
  and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
   [@Image = 'Object' or @Image = 'java.lang.Object'])
)
or
@Image='equal'
 and count(FormalParameters/*) = 1
 and (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
  [@Image = 'Object' or @Image = 'java.lang.Object'])

]
        
                    ]]></value>
         </property>
      </properties>
      <example><![CDATA[
        
    public class Foo {
         public int equals(Object o) {
         // oops, this probably was supposed to be boolean equals
         }
         public boolean equals(String s) {
         // oops, this probably was supposed to be equals(Object)
         }
    }
        
        ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.AvoidNonConstructorMethodsWithClassName" dfa="false" externalInfoUrl="" message="Method ''{0}'' is not a constructor but it can be confused with one" name="AvoidNonConstructorMethodsWithClassName" typeResolution="true">
      <description>
      It is very easy to confuse methods with classname with constructors. It is preferrable
      to name these non-constructor methods in a different way.
      </description>
      <priority>3</priority>
      <example><![CDATA[

public class Foo {
	public void Foo() {
		// not really a constructor...
	}
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="You have a suite() method that is not both public and static, so JUnit won't call it to get your TestSuite.  Is that what you wanted to do?" name="JUnitStaticSuite" typeResolution="true">
      <description>
      The suite() method in a JUnit test needs to be both public and static.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
  //MethodDeclaration[not(@Static='true') or not(@Public='true')]
   [MethodDeclarator/@Image='suite']
   [MethodDeclarator/FormalParameters/@ParameterCount=0]
                
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
  import junit.framework.*;
  public class Foo extends TestCase {
   public void suite() {} // oops, should be static
   private static void suite() {} // oops, should be public
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="You may have misspelled or miscapitalized a JUnit framework method (setUp() or tearDown())" name="JUnitSpelling" typeResolution="true">
      <description>
    Some JUnit framework methods are easy to misspell.
    </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
              
//MethodDeclarator[(not(@Image = 'setUp')
 and translate(@Image, 'SETuP', 'setUp') = 'setUp')
 or (not(@Image = 'tearDown')
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
              
          ]]></value>
         </property>
      </properties>
      <example><![CDATA[

import junit.framework.*;
public class Foo extends TestCase {
 public void setup() {} // oops, should be setUp
 public void TearDown() {} // oops, should be tearDown
}

    ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="user assertEquals(x, y) instead of assertTrue(x.equals(y))" name="UseAssertEqualsInsteadOfAssertTrue" typeResolution="true">
      <description>
          This rule detects JUnit assertions in object equality. These assertions
          should be made by more specific methods, like assertEquals.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                

//PrimaryExpression[
    PrimaryPrefix/Name[@Image = 'assertTrue']
][
    PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
    [ends-with(@Image, '.equals')]
]

 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class FooTest extends TestCase {
    void testCode() {
        Object a, b;
        assertTrue(a.equals(b)); // bad usage
        assertEquals(a, b); // good usage
    }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="user assertSame(x, y) instead of assertTrue(x==y)" name="UseAssertSameInsteadOfAssertTrue" typeResolution="true">
      <description>
          This rule detects JUnit assertions in object references equality. These assertions
          should be made by more specific methods, like assertSame, assertNotSame.
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                

//PrimaryExpression [
    PrimaryPrefix/Name[@Image = 'assertTrue' or @Image = 'assertFalse']
]
[PrimarySuffix/Arguments/ArgumentList/Expression/EqualityExpression[
        @Image = '==' or  @Image = '!='
    ]
]

 
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[

public class FooTest extends TestCase {
    void testCode() {
        Object a, b;
        assertTrue(a==b); // bad usage
        assertSame(a, b);  // good usage
    }
}

      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Always use curly braces around the body of an 'if' statement.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability." name="IfStmtsMustUseBraces" typeResolution="true">
      <description>
     Avoid using if statements without using curly braces
     </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                   
    //IfStatement[count(*) < 3][not(Statement/Block)]
                   
               ]]></value>
         </property>
      </properties>
      <example><![CDATA[
 
 public class Foo {
   public void bar() {
     int x = 0;
     if (foo) x++;
   }
 }
 
     ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Always use curly braces around the body of a 'while' loop.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability." name="WhileLoopsMustUseBraces" typeResolution="true">
      <description>
      Avoid using 'while' statements without using curly braces
      </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                    
    //WhileStatement[not(Statement/Block)]
                    
                ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
    public void doSomething() {
      while (true)
          x++;
    }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Always use curly braces around the body of an 'if' statement and its 'else'.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability." name="IfElseStmtsMustUseBraces" typeResolution="true">
      <description>
       Avoid using if..else statements without using curly braces
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[

//Statement
 [parent::IfStatement[@Else='true']]
 [not(child::Block)]
 [not(child::IfStatement)]
 
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   

     public void doSomething() {
       // this is OK
       if (foo) x++;

       // but this is not
       if (foo)
           x=x+1;
       else
           x=x-1;
     }
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="Always use curly braces around the body of a 'for' loop.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability." name="ForLoopsMustUseBraces" typeResolution="true">
      <description>
       Avoid using 'for' statements without using curly braces
       </description>
      <priority>3</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                     
    //ForStatement[not(Statement/Block)]
                     
                 ]]></value>
         </property>
      </properties>
      <example><![CDATA[
   
     public void foo() {
       for (int i=0; i<42;i++)
           foo();
     }
   
       ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="A test case method should use one or more 'assert...()' methods to check that the desired behavior is actually occurring." name="JUnitTestsHaveAssertions" typeResolution="true">
      <description>
      All JUnit test methods should contain at least one assertion.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
  //MethodDeclaration
[starts-with(MethodDeclarator/@Image, 'test')]
[not(descendant::StatementExpression/PrimaryExpression/PrimaryPrefix/Name
        [starts-with(@Image, 'assert') or contains(@Image,'.assert')
          or @Image = 'fail' or contains(@Image,'.fail')] )]
[ancestor::UnmodifiedClassDeclaration[contains(@Image, 'Test') or contains(@image,'test')]]
                
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
  import junit.framework.*;
  public class Foo extends TestCase {
   public void test1() {} // oops, no assertion!
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This assertion uses only values known at compile time, so it cannot test any useful behavior exhibited by your code at run-time." name="JUnitConstantAssertion" typeResolution="true">
      <description>
      All assertEquals() or assertTrue() assertions in JUnit test methods
      should contain one or more non-literal parameters.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
  //StatementExpression/PrimaryExpression[PrimaryPrefix/Name/@Image='assertTrue' or PrimaryPrefix/Name/@Image='assertEquals'][not(PrimarySuffix/Arguments/ArgumentList/descendant::PrimaryPrefix/Name)][ancestor::UnmodifiedClassDeclaration[contains(@Image, 'Test') or contains(@image,'test')]]
                
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
  import junit.framework.*;
  public class Foo extends TestCase {
   public void test1() {
       assertTrue( true );    // oops, does not test anything useful!
       assertEquals( 0, 0 );  // oops, does not test anything useful!
   }
  }
  
      ]]></example>
   </rule>
   <rule class="net.sourceforge.pmd.rules.XPathRule" dfa="false" externalInfoUrl="" message="This JUnit test class does not contain any actual tests." name="JUnitTestClassNeedsTestCase" typeResolution="true">
      <description>
      All JUnit test classes should contain a test method.
      </description>
      <priority>2</priority>
      <properties>
         <property name="xpath">
            <value><![CDATA[
                
  //UnmodifiedClassDeclaration[contains(@Image, 'Test') or contains(@image,'test')][not(descendant::MethodDeclaration[starts-with(MethodDeclarator/@Image, 'test')])]
                
            ]]></value>
         </property>
      </properties>
      <example><![CDATA[
  
  import junit.framework.*;
  public class Foo extends TestCase {
           // oops, no test cases!
   }
  }
  
      ]]></example>
   </rule>
</ruleset>
